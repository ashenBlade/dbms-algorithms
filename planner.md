# Планировщик

Планировщик - это компонент отвечающий за превращение запроса пользователя в план выполнения этого запроса.
Он является одним из самых сложных и важных, так как:

- Логика, лежащая в его основе должна быть математически корректной (правила реляционной алгебры), иначе ответ будет некорректный;
- От его результата зависит производительность не только этого конкретного запроса, но также других запросов и всей СУБД (операционная деятельность) тоже.

Здесь будет рассмотрен планировщик реляционной СУБД.

## Реляционная алгебра

> Здесь не будет подробного описания реляционной алгебры - предполагаю, что она уже известна, а если нет, то быстрый запрос в поисковике сразу даст подходящие сайты.

В основе реляционной СУБД (РСУБД) лежит реляционная алгебра.

Для запросов к РСУБД используется SQL, но это не тоже самое, что и реляционная алгебра, хотя правила трансформаций для них практически эквивалентны.
Поэтому можно сказать, что работа планировщика связана с трансформацией этого дерева запроса.

## Архитектура

Все планировщики можно поделить на 2 вида:

1. Bottom-up - вначале планируется соединение таблиц (т.е. листья обрабатываются первыми), а поверх них добавляется пост-обработка: сортировка, группировка, LIMIT/OFFSET и т.д.
2. Top-down - для каждого узла, начиная с самого верхнего, планировщик создает список кандидатов путей, а затем удаляет лишние (более дорогие). Также называется, Goal-oriented

Из общего можно выделить то, что планирование JOIN'ов является самой затратной операцией.
За многие года появилось множество алгоритмов планирования.

Их также можно поделить на несколько групп.

Поиск оптимального решения:

- Эвристический - изменения диктуются эвристиками (правилами) и применяются при совпадении шаблона
- Стоимостной - каждое изменение меняет стоимость запроса и перед применением рассчитывается выгода

## Bottom-up

Алгоритм работы Bottom-up планировщика можно описать так:

1. Предобработка дерева запроса
2. Планирование JOIN'ов
3. Добавление пост-обработки

При этом самым затратным является 2 - планирование JOIN'ов.
Для этой категории

## Top-down

## DPsize

DPsize - size-based enumeration.

В основе лежит идея, что для создания JOIN'а из N узлов нужно выбрать лучшую пару множеств, которые в сумме образуют исходное множество.

Это `N` мы пробегаем от 1 до размера множества таблиц всего запроса, а в конце получаем план всего запроса. Для множеств размером 1 мы сразу находим оптимальный план - это одиночные таблицы сразу же, а для остальных - находим оптимальный порядок JOIN'ов.

Псевдокод на C++:

```c++
Relation dpsize(std::vector<Relation> &relations) {
    std::map<RelationId, Relation> rels {};
    
    /* Находим пути для таблиц */
    for (auto &rel: relations) {
        rel.find_best_path();
    }

    /* Сохраняем в таблицу созданных отношений */
    for (const auto &rel: relations){
        rels[rel.id()] = rel;
    }

    /* Проходим по всем множествам */
    for (int n = 2; n < relations.size(); n++) {
        for (int s1 = 1; s1 < n; s1++) {
            int s2 = n - s1;
            for (const auto &left: get_relations_of_size(s1)) {
                for (const auto &right: get_relations_of_size(s2)) {
                    /* Таблицы не должны пересекаться */
                    if ((left & right) != RelationId{}) {
                        continue;
                    }
                    
                    /* Соединяем только если есть предикат */
                    if (!left.joinable_with(right)) {
                        continue;
                    }
                    
                    /* Соединяем отношения */
                    Relation joinrel = join_relations(left, right);

                    /* 
                     * Нет смысла отслеживать созданный путь, если
                     * его стоимость больше стоимости старого пути
                     */
                    auto rel = rels.find(joinrel.id());
                    if (rel == rels.end() ||
                        rel->second.cost() < joinrel.cost()) {
                        rels[joinrel.id()] = joinrel;
                    }
                }
            }
        }
    }

    /* К этому моменту в таблице должен храниться результирующий путь */
    return rels[combine_relids(relations)];
}
```

Для поддержки CROSS JOIN можно изменить условие `left.joinable_with(right)` - возвращать `true`, если CROSS JOIN включены. Это необходимо в том случае, если в процессе не смогли найти план для всего запроса - тогда этот флаг выставляется и создается путь с CROSS JOIN'ами.

Теперь, посмотрим, как это реализовано в PostgreSQL.

### PostgreSQL

Используемые структуры данных:

- `RelOptInfo` - представление множества соединяемых таблиц. Содержит в себе информацию для планировщика (статистика, индексы, предикаты и т.д.), а также список всех построенных путей
- `Relids` - множество, содержащее ID отношений. `RelOptInfo` содержит поле `relids` этого типа, которое содержит все ID отношений, которые этот `RelOptInfo` представляет.
- `Path` (и все структуры, оканчивающиеся на `Path`) - структура представляющая путь выполнения. Это не готовый план выполнения - он содержит информацию для планировщика, но пока не выполнения

Логику поиска JOIN'ов можно описать такой иерархией вызовов:

```text
standard_join_search()
    for n from 2 to N:
        join_search_one_level()
            1. left/right-sided (CROSS JOIN)
            2. bushy plan
            3. CROSS JOIN (no plan yet)
        set_cheapest()
```

- `standard_join_search()` - запуск DPsize алгоритма. Внутри него запускается цикл проходящий по всем размерам множеств.
- `join_search_one_level()` - логика обработки 1 уровня DPsize:
    1. left/right-sided планы - к дереву размером n - 1 присоединяется таблица (размер 1)
    2. bushy план - обычный план в терминах DPsize, проходимся по всем допустимым парам, дающим n в сумме отношений (отражает основной код DPside)
    3. CROSS JOIN - последняя попытка создать планы (запускается только если не смогли создать вообще никакого плана для этого уровня)
- `set_cheapest()` - для всех найденных отношений размером n находим самый дешевый план

Какие моменты примечательны:

1. Вначале строится left/right-sided, соединяющий дерево с 1 таблицей, причем безусловно - если нет предиката, то создается CROSS JOIN.
   Многие примеры кода DPsize имеют условие включающее создание CROSS JOIN'ов. Это необходимо для случаев, когда между таблицами отсутствовала связь - в этом случае не удастся создать план для всего дерева. Тогда планировщик пытается создать план, соединяющий все со всеми.
   Легко понять, что тогда сложность будет честно экспоненциальной (т.к. клика), вместо возможной полиномиальной (например, для цепочки).
2. Вместо обновления лучшего плана каждый раз, они сохраняются, а затем выбирается лучший. Это необходимо по нескольким причинам:
    - В конце цикла `standard_join_search()` выполняются доп. этапы - добавление параллельных путей и путей для партиционированных таблиц
    - Пути выполнения сравниваются по разным критериям и чтобы найти лучший нужно просмотреть все
3. Даже при том, что все пути сохраняются, иногда при добавлении путей мы сразу же можем понять, что путь можно выкинуть из рассмотрения (см. ниже)

Основная логика добавления пути находится в функции `add_path`. В процессе создания JOIN'ов для разных пар вызывается функция `add_paths_to_joinrel` - она создает все возможные стратегии выполнения узла JOIN'а (хэш, сортировка, NL и т.д.), но в конечном счете все сводится к `add_path` - функции добавляющей путь в список кандидатов.

Но добавлять *все* возможные пути не самая лучшая стратегия, так как может найтись пара, один из путей которой лучше по показателям. Но что это за показатели:

1. Полная стоимость выполнения узла (`total_cost`)
2. Стоимость подготовки узла (`startup_cost`)
3. Отсортированные столбцы (`keys`)

Сам Postgres добавляет к этому списку:

1. Атрибуты параметризации (`param_attr`) - если этот узел JOIN'а использует предикаты, содержащие отношения вне этого JOIN'а, т.е. атрибуты верхних узлов пробрасываются под этот JOIN (например, для использования предикатов индекса)
2. Кардинальность
3. Возможность параллелизации

В такой постановке, даже если один путь дешевле чем другой, но он отличается хотя бы на 1 сортируемый атрибут - сравнивать их нельзя. Поэтому для облегчения задачи используется (очень грубо говоря) сравнение кортежей: (`total_cost`, `startup_cost`, `keys`, `param_attr`). Удалять старый путь или не добавлять новый мы решаем только если:

1. `total` и `startup` стоимость можно сравнить (т.е. они не разные - один больше, а другой меньше)
2. `keys` одного - подмножество другого (т.е. не содержат разные элементы)

Но даже так, логика сравнения довольно сложна и зависит от комбинации значений и в каждой такой комбинации проверяются разные свойства. Но обобщая можно сказать, что:

- Старый путь удаляется, если он:
  - Хуже по параметризации
  - Хуже по отсортированным столбцам
  - Возвращает больше строк
- В противном случае, либо новый путь не добавляется, либо все остается на местах

Также, для сравнения стоимостей используется не простое сравнение значений, а нечеткое (`compare_path_costs_fuzzily`) - при сравнении применяется множитель немного уменьшающий стоимость другого узла. Это нужно по 2 причинам:

1. Тип стоимости - `double`, а он имеет проблемы с точностью, поэтому добавляя этот множитель мы немного можем избавиться от проблем.
2. Стоимость взята приблизительно, поэтому мы (практически полностью) можем быть уверены в том, что один из путей дешевле чем другой только если его стоимость кратно отличается от стоимости другого.

Для создания JOIN'ов используется несколько функций:

- `make_join_rel` - общая функция, которая создает JOIN узел для любых 2 отношений. Основное требование - отношения не пересекаются (нет общих таблиц).
- `make_rels_by_clause_joins`/`make_rels_by_clauseless_joins` - вспомогательные функции, которые создают все возможные JOIN'ы для переданного отношения. Первый - если требуется проверка на существование JOIN предиката, а другой - создает даже CROSS JOIN.
    Используется в 1 и 3 шагах `join_search_one_level`.

Работа `make_join_rel` устроена следующим образом:

1. Определяется подходящий тип JOIN'а
2. Определяется предикат для этого JOIN'а
3. Создается структура `RelOptInfo`
4. Добавляются все возможные пути для пары отношений

Как определяется, что отношения можно соединить (передано 2 `RelOptInfo`):

1. В одном `RelOptInfo` есть `RestrictInfo` (в `joininfo`), у которого `required_relids` содержит общие ID с другим отношением
2. Имеют общие `EquivalenceClass`'ы

TODO: разрешенные перемещения для OUTER JOIN (из README)

## GEQO
